---
# This template describes how to create a patternset. A template without the descriptions is also available. Patternsets are YAML or JSON files that describe and validate syntactic rules. When a sentence or chunk of text is run through the detector, the input is compared to each item in `patterns`. These items, each representing a rule and its corresponding syntactic pattern, are added to the underlying `Matcher` from the spaCy package's `Matcher`. When a pattern matches, the detector outputs the result.
# A result is of type `tuple[str, spacy.tokens.Span, dict[str, str]]`,
# and consists of the following components:
# 1) the matching rulename as a `str`,
# 2) the matching `Span` instance (to be used as a `Span` or as a `str`), and
# 3) a `dict[str, str]` containing other attributes pertaining to the match (e.g. `dep` (dependency), `dep_desc` (description of dependency), `root`, `root_head`, etc.).
#
# The file extension is determined by `settings.py`. The default patternsets are good references for formatting and readability. When errors occur in the output, this usually indicates that the `tokens` pattern needs improvement. An error in output does not typically indicate the requirement of any additional code.


### Components of a patternset ###

#### Meta ####

# meta (`dict[str, Union[str, bool, int, float]]`): The `meta` attribute  consists of settings that modify the input and output. Writing every feature out in code is not feasible. For this reason, most of the configuration comes from these patternset files. When a setting must be hardcoded, it should be configured here.
meta:

    # extract_noun_chunks (`bool`): If `true`, then a sentence or chunk of input is broken up into noun chunks. This changes the input from `doc` to `doc.noun_chunks`. This feature is why the matcher both expects and outputs a `list[str]`, and also why the `doc` must be inserted in a list by itself. Valid values are: `true`, `false`. Defaults to `false`.
    extract_noun_chunks: false

    # how_many_matches (`str`): When set to `"one"`, the best match is taken, which is currently the match with the longest `Span`. This setting is appropriate when detecting for features like a sentence's transitivity or a noun's determiner. When set to `"all"`, all results are returned. This setting is appropriate for features like detecting the determiners for all nouns in a sentence. If extract_noun_chunks is `true`, this setting will typically be `true` as well. Valid values are: `"one"`, `"all"`. Defaults to `"one"`.
    how_many_matches: one

    # NYI - Not yet implemented due to lack of need. Defaults to `"longest"`.
    # best_match: longest
    

    # skip_tests (`Union[str, bool]`): If `true`, then all tests in the `tests` key will be ignored by the unittest module. If `str`, then the value will also be logged. If `false`, then the `tests` will be run. Defaults to `false`.
    # skip_tests: true
    # skip_tests: not yet implemented
    skip_tests: false


#### Patterns ####

# patterns (`dict[str, Union[str, list[spacy.tokens.Token]]]`): The core component of the patternsets. Each item in this list is its own rule. When the detector is run, the input is checked against these patterns. When a pattern is matched, the corresponding rulename and matching `Span` are part of the result.
patterns:

    ##### **The start of rule #1**
    # rulename (`str`): The name corresponding to the `tokens`. When a pattern is detected, this is the 1st value of the detector's output. Each `rulename` must be unique. Creating separate entries with the same `rulename` and/or the same `tokens` is undefined behavior and not recommended. The intended way of creating multiple versions of the same rule is to slightly modify the `rulename`. A good example of this is the future simple patterns in the `tense_aspects` patternset.
    - rulename: "present simple"

      # tokens (`list[spacy.tokens.Token]`): The syntax pattern corresponding to the `rulename`. Each hyphenated dictionary represents a single spaCy `Token`, which in turn typically represents a single word. Any text that matches the pattern of `tokens` will be detected and extracted. JSON-esque formatting is usually the most effective for readability because of how YAML objects/dicts are laid out. However, the .json extension itself does not support comments.
      tokens:
          - {TAG: {IN: ["VBP", "VBZ"]}, OP: "+"}
    ##### **The end of rule #1**

    ##### **The start of rule #2**
    - rulename: present simple passive  # Valid; special characters are escaped
      tokens:
          - {  # The 1st token
              TAG: {IN: ["VBP", "VBZ"]},
              DEP: auxpass,  # Valid; "quotation marks" for values is optional but recommended
              LEMMA: "be",  # Valid
              OP: "+",  # OP values must always be in "quotation marks"
          }
          - {TAG: "VBN", OP: "+"}  # The 2nd token
    ##### **The end of rule #2**

    # An example rule for tense-aspects
    - rulename: future simple be-going-to
      tokens:
          - {TAG: {IN: ["VBP", "VBZ"]}, DEP: "aux", OP: "+"}
          - {TAG: "VBG", OP: "+", LEMMA: "go"}
          - {TAG: "TO", DEP: "aux", OP: "+"}
          - {TAG: "VB", DEP: "xcomp", OP: "+"}


#### Tests ####
# The tests can be run using the following command: $ python -m unittest

# tests (`list[dict[str, Union[str, list[str]]]]`): The automated tests that are run when calling the unittest package in the CLI. The output of the detector is compared to the rulenames and spans attributes. A test consists of an `input` of type `str`, `rulenames` of type `list[str]`, and `spans` of type `list[str]`.
tests:

    ##### **The start of test #1**
    # input (str): The sentence or chunk of text to be fed to the detector.
    - input: He chases it.

      # rulenames (list[str]): The expected matching rulenames that the detector should output. A test must have at least one of these: rulenames, spans. These are **always** a list of strings, even when matching for one.
      rulenames:
          - present simple

      # spans (list[str]): The expected matching text that the detector should output. A test must have at least one of these: rulenames, spans. These are **always** a list of strings, even when matching for one.
      spans:
          - chased

      # skip (`Union[str, bool]`): If `true`, then this individual test will be ignored by the unittest module. If `str`, then the value will also be logged. If `false`, then the `tests` will be run. Defaults to `false`.
      # skip: true
      # skip: not yet implemented
      skip: false
    ##### **The end of test #1**

    ##### **The start of test #2**
    - input: He is chased by it.
      rulenames:
          - present simple passive
      spans:
          - is chased
    ##### **The end of test #2**

    # An example test with multiple results and documented test failure
    - input: the book that was on a shelf behind the TV
      skip: true   # When true, the test is skipped. Defaults to false.
      rulenames:
          - definite  # missing - FIXME this result was expected
          # none - FIXME this result was unexpected
          - indefinite  # other - FIXME this result is incorrect
          - definite
      spans:
          - the book
          - a shelf
          - the TV
